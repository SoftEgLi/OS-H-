<h2>实现思路</h2>
<h4>页表</h4>
&nbsp;&nbsp;&nbsp;&nbsp;实现四级页表。当某级页表项不存在，若alloc为真，则将该级页表，及往后的页表项创建出来。  
<h4>定时器</h4>
&nbsp;&nbsp;&nbsp;&nbsp;在set_cpu_on函数中设置自定义的定时器，在定时器中存储u64 data,每次定时器被调用，则将data++。在调度的时候，会将data和调度队列元素的数量取余，来实现轮询的调度策略。  
<h4>调度算法</h4>
&nbsp;&nbsp;&nbsp;&nbsp;采用轮询的调度算法，会根据data和调度队列元素的数量的取余值，来寻找下一个被调度对象所处的位置。 
<h4>出现的问题</h4>
1.在触发中断后，没有将daif寄存器关闭，导致接连触发中断，将栈占满。  
解决办法：在trap_entry中，仿照_arch_disable_trap函数，将中断关闭。  
2.死锁问题，进程在获得调度锁后，释放调度锁前，陷入时钟中断，而时钟中断处理函数无法获得调度锁，导致死锁问题。  
    解决办法：在获得调度锁前先将中断关闭，释放锁后根据_arch_disable_trap返回的布尔量来确定是否需要打开中断。
<h2>创新点</h2>
    使用了轮询的调度算法，大多数情况下调度公平。识别并解决了一些潜在的并发问题。
<h2>思考题</h2>
Q：为什么如果当前进程带有标记，且new_state不为zombie，则调度器直接返回，不做任何操作？
A：这样可以提高效率，避免不必要的资源消耗。当一个进程被标记为killed时，通常表示它将被终止或撤销，不再需要执行。此时只需要等待触发时钟中断将其exit掉即可。

